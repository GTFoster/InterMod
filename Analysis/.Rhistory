if(int_fail==TRUE){ #If we've come across an integration failure, break the loop
break()
}
for(a2 in 1:n_animals){
temp <- try(integrate(min.f1f2, -Inf, Inf, mu1=a_traitM[a2], mu2=a_traitM[ia], sd1=a_traitV[a2], sd2=a_traitV[ia])$value) #Integrate our minimum equation over all numbers; output is the total area overlapping both curves, with max value of perfectly overlapping curves as 1
if(class(temp)=='try-error'){
int_fail <- TRUE
break()
}
o[ia, a2]<- temp
#print(paste("ia=", ia, "; ip=", ip, sep=""))
}
}
}
prior_richness <- richness
prior_richness
#Find out dpop/dt
a_change <- matrix(data=NA, nrow=nsites, ncol=n_animals)
for(n in 1:n_animals){
propOfplants <- 0
nums <- alpha[n,]*p_pops/K#[,site] What if we standardize plant species to K? This seems like it might have worked to fix my problem
for(i in 1:n_plants){
#Numerator-plant reward given by each focal pollinator
propOfplants <- propOfplants+nums[,i]/(r+sum(alpha[,i]*a_pops)) #Denominator-scaled by total available pollen
}
pollDeath <- mua
#print(propOfplants)
a_change[,n] <- lambda*((1-(o[,n]%*%t(a_pops))/K))*propOfplants# - pollDeath
} #Animal Growth Rate
a_change
propOfplants
propOfplants
propOfplants
sum(propOfplants)
propOfplants
alpha
alpha
rowSums(alpha)
colSums(alpha)
alpha
propOfplants
r+sum(alpha[,i]*a_pops
)
nums[,i]/(r+sum(alpha[,i]*a_pops
)
()
)
nums
sd(nums)
View(a_change)
knitr::opts_chunk$set(echo = TRUE)
flowdat <- read.csv(file="Flow_old.csv")[1:3,c(1:2,4:9)]
divdat <- read.csv(file="Diversity_old.csv")[,1:4]\
knitr::opts_chunk$set(echo = TRUE)
flowdat <- read.csv(file="Flow_old.csv")[1:3,c(1:2,4:9)]
divdat <- read.csv(file="Diversity_old.csv")[,1:4]
flowdat$time1 <- c(40.3, 9.2, 15.4)
flowdat$time2 <- c(40.3+runif(1,-2,2), 9.2 + +runif(1,-2,2), 15.4+runif(1,-2,2))
flowdat$time3 <- c(40.3+runif(1,-2,2), 9.2 + +runif(1,-2,2), 15.4+runif(1,-2,2))
flowdat$length <- c(5.3,4.8,4.2)
colnames(divdat) <- c("section", "site", "ID", "count")
flowdat$avg_depth <- (flowdat$Depth1_m + flowdat$Depth2_m + flowdat$Depth3_m)/5
flowdat$cross_area <- flowdat$avg_depth*flowdat$Width_m
flowdat$avg_time <- (flowdat$time1 + flowdat$time2+ flowdat$time3)/3
flowdat$velocity <- flowdat$length/flowdat$avg_time
flowdat$cms <- flowdat$velocity*flowdat$cross_area
flowdat$cfs <- flowdat$cms*35.314
flowdat$gpm <- flowdat$cfs*7.48*60
flowdat$gpd <-flowdat$gpm*60*24
library(tidyverse)
library(vegan)
divdat <- divdat %>% #The data we're going to summarize
group_by(site) %>% #We use group by to tell R we want a different summarize by site
mutate(., sumCount=sum(count)) #Mutate tells R to make a new column with whatever operation we want-here we sum the counts
View(divdat)
?vegan::diversity()
vegan::diversity(divdat$count)
vegan::diversity(divdat$count, index ="shannon")
vegan::diversity(divdat, index="shannon", groups=site)
divdat$relabundance <- divdat$count/divdat$sumCount
divdat$LNrelabund <- log(divdat$relabundance)
divdat$relabundance*divdat$LNrelabund
divdat$simp_cont <- divdat$relabundance*divdat$LNrelabund
divdat <- divdat %>% #The data we're going to summarize
group_by(site) %>% #We use group by to tell R we want a different summarize by site
mutate(., Simpsons=sum(simp_cont)) #Mutate tells R to make a new column with whatever operation we want-here we sum the counts
divdat$relabundSq <- divdat$relabundance^2
divdat$relabundSq
divdat <- divdat %>% #The data we're going to summarize
group_by(site) %>% #We use group by to tell R we want a different summarize by site
mutate(., Simpsons=-1*sum(simp_cont)) #Mutate tells R to make a new column with whatever operation we want-here we sum the counts
Simpsons <- divdat %>% #The data we're going to summarize
group_by(site) %>% #We use group by to tell R we want a different summarize by site
summarize(., Simpsons=-1*sum(simp_cont)) #Mutate tells R to make a new column with whatever operation we want-here we sum the counts
View(Simpsons)
Shannon <- divdat %>% #The data we're going to summarize
group_by(site) %>% #We use group by to tell R we want a different summarize by site
summarize(., Simpsons=1-*sum(relabundSq))
Shannon <- divdat %>% #The data we're going to summarize
group_by(site) %>% #We use group by to tell R we want a different summarize by site
summarize(., Simpsons=1-sum(relabundSq))
Shannon
Counts <- divdat %>% #The data we're going to summarize
group_by(site) %>% #We use group by to tell R we want a different summarize by site
summarise(., sumCount=sum(count)) #Mutate tells R to make a new column with whatever operation we want-here we sum the counts
Counts
170*2+130+50+100+25
170*2+130+50+100+30
155/650
170/650
130/650
130*5
50/650
100/650
30/650
26*2+20+12+20
50+20
25+20+25+7+4+15+5
155/650
170+130+170
470/650
160/650
140/650
25+21+25+7+4+15
+5
100/659
100/650
25/650
30/650
25+21+25+7+4+15+4
load("~/Documents/Fruglink/Data.nosync/FullData/fullReplicateRF_predicts.Rda")
load("~/Documents/Fruglink/ttsplitReplicateRF.Rda")
split_output[[1]]
class(split_output[[1]]$Phy)
class(full_output[[1]]$Phy)
knitr::opts_chunk$set(echo = TRUE)
library(rjson)
library(tidyverse)
# define the base url
base_url <- "https://www.web-of-life.es/"
json_url2 <- paste0(base_url,"get_networks.php?interaction_type=Pollination")
WolPols <- jsonlite::fromJSON(json_url2)
length(unique(WolPols$network_name)) # 166 Networks
knitr::opts_chunk$set(echo = TRUE)
library(rjson)
library(tidyverse)
# define the base url
base_url <- "https://www.web-of-life.es/"
json_url2 <- paste0(base_url,"get_networks.php?interaction_type=Pollination")
WolPols <- jsonlite::fromJSON(json_url2)
length(unique(WolPols$network_name)) # 166 Networks
WolMeta <- read.csv(paste0(base_url,"get_network_info.php"))
# show results
head(WolMeta) # %>% formattable()
colnames(WolMeta)
WolMeta <- WolMeta %>% dplyr::filter(., network_type%in%"Pollination")
length(unique(WolMeta$network_name))
table(unique(WolPols$network_name)%in%WolMeta$network_name)
table(WolMeta$region)
amPol <- WolMeta %>% dplyr::select(., network_name, region, latitude, longitude) %>% left_join(WolPols, ., by="network_name") %>% dplyr::filter(., region=="Americas")
length(unique(amPol$network_name))
table(amPol$species1 %in% amPol$species2)
amPlants <- amPol %>% dplyr::select(., network_name, species1) %>% unique() #All the unique plant-site combinations in us
amPollinators <- amPol %>% dplyr::select(., network_name, species2) %>% unique() #All the unique poll-site combinations in us
sum(table(rowSums(table(amPlants$species1, amPlants$network_name))))-sum(table(rowSums(table(amPlants$species1, amPlants$network_name)))[1:5])
sum(table(rowSums(table(amPollinators$species2, amPollinators$network_name))))-sum(table(rowSums(table(amPollinators$species2, amPollinators$network_name)))[1:5])
library(rmangal)
mgs <- rmangal::search_datasets("pollinator")
mgn <- get_collection(mgs)
nodes <- mgn[[1]]$nodes
mgn[[1]]$interactions
mgn[[1]]$network
summary(mgn)[[1]]
setwd("~/Downloads/BioticSDMs")
## Load packages
require(spdep)
require(RANN)
require(INLA)
## Read in data
data <- read.table("sample.txt", header=T)
data
## Function from Beale et al. 2014
sortBase <- function(vec, n.knots = 2) {
## Function to calculate bases for regression splines. Modified from code
## provided in Crainiceanu, C., Ruppert, D. & Wand, M.P. Bayesian analysis for
## penalized spline regression using WinBUGS. J. Stat. Soft. 14, 1?24(2005).
## Parameter vec is a vector defining the raw data vector, n.knots defines the
## number of knots in the GAM.
N              <- length(vec)
x.time         <- c(vec)
ZFE            <- cbind(rep(1,N), x.time)
x.knots        <- quantile(unique(x.time), seq(0, 1,
length = (n.knots+2))[-c(1, (n.knots+2))], na.rm = TRUE)
Z_K            <- (abs(outer(x.time,x.knots,"-")))^3
OMEGA.all      <- (abs(outer(x.knots,x.knots,"-")))^3
svd.OMEGA.all  <- svd(OMEGA.all)
sqrt.OMEGA.all <- t(svd.OMEGA.all$v %*% (t(svd.OMEGA.all$u)*
sqrt(svd.OMEGA.all$d)))
Z.out          <- t(solve(sqrt.OMEGA.all, t(Z_K)))
return(Z.out)
}
## Define regression splines
Z.var1 <- matrix(c(scale(sortBase(data[,4]))), ncol = 2)
Z.var2 <- matrix(c(scale(sortBase(data[,5]))), ncol = 2)
## Calculate distance between cells for CAR component
coords <- SpatialPoints(as.matrix(data[,1:2]))
k1 <- knn2nb(knearneigh(coords, longlat=TRUE))
all.linked <- max(unlist(nbdists(k1, coords)))
neb <- dnearneigh(coords, 0, all.linked)
neb2 <- nb2mat(neb)
neb2[neb2>0] <- 1
## Prepare model
y=1000 #Number of grid cells
node_CAR <- rep(1:y, times=1, length.out=y, each=1)
z=10 #Shape parameter
hyperpar_CAR <- list(param=c(z, 0.001))
formula_CAR_mod1 <- spp1 ~ Z.var1[,1] + Z.var1[,2] + Z.var2[,1] + Z.var2[,2] +
f(node_CAR, model="besag", graph=neb2,
hyper=list(theta=hyperpar_CAR))
## INLA model
model_CAR_mod1   <- inla(formula=formula_CAR_mod1, data=data, family="binomial",
control.compute=list(dic=TRUE, waic=TRUE),
control.fixed=list(prec.intercept=0.001, prec=0.001),
verbose=FALSE)
summary(model_CAR_mod1)
## Function from Beale et al. 2014
sortBase <- function(vec, n.knots = 2) {
## Function to calculate bases for regression splines. Modified from code
## provided in Crainiceanu, C., Ruppert, D. & Wand, M.P. Bayesian analysis for
## penalized spline regression using WinBUGS. J. Stat. Soft. 14, 1?24(2005).
## Parameter vec is a vector defining the raw data vector, n.knots defines the
## number of knots in the GAM.
N              <- length(vec)
x.time         <- c(vec)
ZFE            <- cbind(rep(1,N), x.time)
x.knots        <- quantile(unique(x.time), seq(0, 1,
length = (n.knots+2))[-c(1, (n.knots+2))], na.rm = TRUE)
Z_K            <- (abs(outer(x.time,x.knots,"-")))^3
OMEGA.all      <- (abs(outer(x.knots,x.knots,"-")))^3
svd.OMEGA.all  <- svd(OMEGA.all)
sqrt.OMEGA.all <- t(svd.OMEGA.all$v %*% (t(svd.OMEGA.all$u)*
sqrt(svd.OMEGA.all$d)))
Z.out          <- t(solve(sqrt.OMEGA.all, t(Z_K)))
return(Z.out)
}
## Define regression splines
Z.var1 <- matrix(c(scale(sortBase(data[,4]))), ncol = 2)
Z.var2 <- matrix(c(scale(sortBase(data[,5]))), ncol = 2)
## Calculate distance between cells for CAR component
coords <- SpatialPoints(as.matrix(data[,1:2]))
require(INLA)
## Load packages
require(spdep)
require(RANN)
require(INLA)
mgn
setwd("~/Documents/InterMod/Analysis")
WolMeta
amPol
save(mgn, amPol, file="Mangel_Wol_Query.Rda")
save(mgn, amPol, file="data/Mangel_Wol_Query.Rda")
load("~/Documents/InterMod/Analysis/data/Mangel_Wol_Query.Rda")
load("data/Mangel_Wol_Query.Rda")
amPol
View(amPol)
table(amPol$species1 %in% amPol$species2)
mgn
View(mgn)
mgn[[1]]
mgn[[1]]$nodes
length(mgn)
temp <- NULL
for(i in 1:length(mgn)){
temp <- rbind(temp, mgn)
}
View(temp)
temp <- NULL
2+2
temp <- NULL
for(i in 1:2){
temp <- rbind(temp, mgn[[i]])
}
View(temp)
mgn[[i]]
mgn[[i]]$nodes
mgnNodes <- NULL
for(i in 1:2){
mgnNodes <- rbind(mgnNodes, mgn[[i]]$nodes)
}
View(mgnNodes)
length(mgn)
mgnNodes <- NULL
for(i in 1:length(mgn)){
mgnNodes <- rbind(mgnNodes, mgn[[i]]$nodes)
}
View(mgnNodes)
unique(mgnNodes$network_id)
length(unique(mgnNodes$network_id))
mgn[[10]]$nodes
mgn[[11]]$nodes
colnames(mgn[[11]]$nodes) %in% colnames(mgn[[10]]$nodes)
colnames(mgn[[10]]$nodes) %in% colnames(mgn[[11]]$nodes)
colnames(mgn[[10]]$nodes)[19]
colnames(mgn[[10]]$nodes)
mgn[[i]]$nodes[1:18]
mgnNodes <- NULL
for(i in 1:length(mgn)){
mgnNodes <- rbind(mgnNodes, mgn[[i]]$nodes[1:18])
}
mgnNodes <- NULL
for(i in 1:length(mgn)){
mgnNodes <- rbind(mgnNodes, mgn[[i]]$nodes[1:18])
}
mgnNodes
(length(unique(mgnNodes$network_id))
(length(unique(mgnNodes$network_id)))
()
length(unique(mgnNodes$network_id))
length(unique(mgnNodes$network_id))
i <- 1
colnames(mgn[[1]]$nodes)
colnames(mgn[[1]]$nodes)[1:18]
cols <- colnames(mgn[[1]]$nodes)[1:18]
cols
temp <- mgn[[i]]$nodes %>% dplyrr::select(., col)
temp <- mgn[[i]]$nodes %>% dplyr::select(., col)
temp <- mgn[[i]]$nodes %>% dplyr::select(., cols)
temp <- mgn[[i]]$nodes %>% dplyr::select(., all_of(cols))
temp
cols <- colnames(mgn[[1]]$nodes)[1:18]
mgnNodes <- NULL
for(i in 1:length(mgn)){
temp <- mgn[[i]]$nodes %>% dplyr::select(., all_of(cols))
mgnNodes <- rbind(mgnNodes, temp)
}
(length(unique(mgnNodes$network_id)))
(length(unique(mgnNodes$network_id)))==324
mgnNodes %>% dplyr::group_by(., taxonomy.id) %>% dplyr::summarise(., networks=length(unique(network_id)))
MangelCounts <- mgnNodes %>% dplyr::group_by(., taxonomy.id) %>% dplyr::summarise(., networks=length(unique(network_id)))
View(MangelCounts)
mgnNodes$taxonomy.name[mgnNodes$taxonomy.id==5038][1]
mgnNodes$taxonomy.name[mgnNodes$taxonomy.id==5041][1]
mgnNodes$taxonomy.name[mgnNodes$taxonomy.id==2164][1]
mgnNodes$taxonomy.name[mgnNodes$taxonomy.id==5068][1]
mgnNodes$taxonomy.name[mgnNodes$taxonomy.id==1608][1]
mgnNodes$taxonomy.name[mgnNodes$taxonomy.id==2965][1]
mgnNodes$original_name[mgnNodes$taxonomy.id==2965][1]
mgnNodes$original_name
mgnNodes$taxonomy.id==2965]
mgnNodes$taxonomy.id%in% 2965
mgnNodes$original_name[mgnNodes$taxonomy.id%in% 2965]
mgnNodes$original_name[mgnNodes$taxonomy.id%in% 2965][1]
mgnNodes$original_name[mgnNodes$taxonomy.id%in% 5038][1]
LiNets <- dplyr::filter(mgnNodes, taxonomy.name=="Lasioglossum incompletum")
View(LiNets)
LiNets <- dplyr::filter(mgnNodes, taxonomy.name=="Lasioglossum incompletum") %>% dplyr::select(., network_id) %>% unique()
View(LiNets)
mgn[[1]]
mgn[[1]]$network
mgn[[1]]$network[[1]]
mgn[[2]]$network[[1]]
for(i in 1:length(mgn)){
if(mgn[[i]]$network[[1]] %in% LiNets$network_id){
print(i)
}
}
mgn[[8]]
mgn[[8]]$interactions
x <- mgn[[8]]$interactions
View(x)
for(i in 1:length(mgn)){
if(mgn[[i]]$network[[1]] %in% LiNets$network_id){
print(i)
}
}
x <- mgn[[30]]$interactions
MangelCounts <- mgnNodes %>% dplyr::group_by(., taxonomy.id) %>% dplyr::summarise(., networks=length(unique(network_id)))
x <- mgn[[8]]$interactions
HtNets <- dplyr::filter(mgnNodes, taxonomy.name=="Halictus tripartitus") %>% dplyr::select(., network_id) %>% unique()
HtNets
x <- mgn[[8]]$interactions
mgn[[8]]$nodes
y <- mgn[[8]]$nodes
View(y)
```{r}
mgn[[i]]$interactions
mgn[[1]]$interactions
colnames(mgn[[1]]$interactions)
colnames(mgn[[1]]$interactions)[1:6]
cols <- colnames(mgn[[1]]$interactions)[1:6]
mgn[[1]]$interactions)
mgn[[1]]$interactions
colnames(mgn[[1]]$interactions)
cols <- colnames(mgn[[1]]$interactions)[c(1:6,"network_id")]
cols
cols <- colnames(mgn[[1]]$interactions)[]
cols <- colnames(mgn[[1]]$interactions)1:6]
cols <- c(colnames(mgn[[1]]$interactions)[1:6],"network_id")
cols
mgnInt[[i]]$interactions
mgn[[i]]$interactions
cols <- c(colnames(mgn[[1]]$interactions)[1:6],"network_id")
mgnInt <- NULL
for(i in 1:length(mgn)){
temp <- mgn[[i]]$interactions %>% dplyr::select(., all_of(cols))
mgnInt <- rbind(mgnInt, temp)
}
mgnInt
unique(mgnInt$node_from) %in% unique(mgnInt$node_to)
table(unique(mgnInt$node_from) %in% unique(mgnInt$node_to))
View(mgnInt)
mgnCounts <- mgnInt %>% group_by(., node_from)) %>% dplyr::summarise(., networks=length(unique(network_id)))
mgnCounts <- mgnInt %>% group_by(., node_from) %>% dplyr::summarise(., networks=length(unique(network_id)))
mgnCounts
View(mgnCounts)
mgnInt %>% group_by(., node_from)
mgn[[1]]$interactions
mgnInt$node_from[1]
mgnNodes$taxonomy.name[mgnInt$node_from[1] %in% mgnNodes$node_id]
mgnInt$node_from[1]
mgnNodes$node_id]
mgnNodes$node_id
mgnNodes$taxonomy.name[mgnInt$node_from[1] %in% mgnNodes$node_id]
node_from[1]
mgnInt$node_from[1]
mgnNodes$node_id
mgnNodes$taxonomy.name[mgnNodes$node_id %in% mgnInt$node_from[1]]
mgnNodes$node_id
mgnInt$node_from[1]
mgnNodes$taxonomy.name[mgnNodes$node_id == mgnInt$node_from[1]]
mgnInt$node_from[1]
mgnNodes$node_id
mgnNodes$node_id == mgnInt$node_from[1]
table(mgnNodes$node_id == mgnInt$node_from[1])
mgnNodes$original_name[mgnNodes$node_id == mgnInt$node_from[1]]
26/1.25
cols <- c(colnames(mgn[[1]]$interactions)[1:6],"network_id")
cols
mgnNodes$original_name[mgnNodes$node_id == mgnInt$node_from[1]]
mgnNodes$original_name[mgnNodes$node_id == mgnInt$node_from[1]]
mgnNodes$node_id == mgnInt$node_from[1]
mgnNodes$node_id == mgnInt$node_from[1]
[mgnNodes$node_id == mgnInt$node_from][1]
mgnInt$sp1name[mgnNodes$node_id == mgnInt$node_from][1]
mgnInt$sp1name <- NA
mgnInt$sp1name[mgnNodes$node_id == mgnInt$node_from][1]
mgnNodes$original_name[mgnNodes$node_id == mgnInt$node_from[1]]
mgnInt$sp1name[mgnNodes$node_id == mgnInt$node_from][1] <- mgnNodes$original_name[mgnNodes$node_id == mgnInt$node_from[1]]
mgnInt$sp1name
mgnNodes$original_name[mgnNodes$node_id == mgnInt$node_from[1]]
mgnInt$node_from[1]
mgnNodes$original_name[mgnNodes$node_id == mgnInt$node_from[2]]
name <- mgnNodes$original_name[mgnNodes$node_id == mgnInt$node_from[1]]
mgnNodes$original_name
name <- mgnNodes$original_name[mgnNodes$node_id == mgnInt$node_from[1]][1]
name
mgnInt
colnames(mgnInt)
colnames(mgnNodes)
colnames(mgnInt) %in% colnames(mgnNodes)
colnames(mgnInt)
colnames(mgnNodes)
mgnInt
colnames(mgnNodes)
colnames(mgnNodes)
mgnInt %>% dplyr::rename(., nade_from=node_id)
mgnInt %>% dplyr::rename(., node_from=node_id)
mgnInt %>% dplyr::rename(., node_id=node_from)
mgnInt %<>% dplyr::rename(., node_id=node_from)
mgnInt <- mgnInt %>% dplyr::rename(., node_id=node_from)
mgnInt
colnames(mgnNodes)
colnames(mgnInt) %in% colnames(mgnNodes, node_id, taxonomy.id, taxonomy.name)
dplyr::select(mgnNodes, node_id, taxonomy.id, taxonomy.name)
dplyr::select(mgnNodes, node_id, taxonomy.id, taxonomy.name) %>% dplyr::rename(., node_from=node_id, taxonomy.id.from=taxonomy.id, taxonomy.name.from=taxonomy.name)
x <- dplyr::select(mgnNodes, node_id, taxonomy.id, taxonomy.name) %>% dplyr::rename(., node_from=node_id, taxonomy.id.from=taxonomy.id, taxonomy.name.from=taxonomy.name)
mgnInt <- mgnInt %>% dplyr::rename(., node_from=node_id)
x <- dplyr::select(mgnNodes, node_id, taxonomy.id, taxonomy.name) %>% dplyr::rename(., node_from=node_id, taxonomy.id.from=taxonomy.id, taxonomy.name.from=taxonomy.name)
mgnInt <- NULL
for(i in 1:length(mgn)){
temp <- mgn[[i]]$interactions %>% dplyr::select(., all_of(cols))
mgnInt <- rbind(mgnInt, temp)
}
mgnInt <- dplyr::select(mgnNodes, node_id, taxonomy.id, taxonomy.name) %>% dplyr::rename(., node_from=node_id, taxonomy.id.from=taxonomy.id, taxonomy.name.from=taxonomy.name) %>% left_join(mgnInt, ., by="node_from")
View(mgnInt)
mgnInt <- dplyr::select(mgnNodes, node_id, taxonomy.id, taxonomy.name) %>% dplyr::rename(., node_to=node_id, taxonomy.id.to=taxonomy.id, taxonomy.name.to=taxonomy.name) %>% left_join(mgnInt, ., by="node_to") #Adding the node_from taxa ID
View(mgnInt)
mgInt$InterID <- as.numeric(paste(mgnInt$taxonomy.id.from, mgnInt$taxonomy.name.to, sep="-"))
mgnInt$InterID <- as.numeric(paste(mgnInt$taxonomy.id.from, mgnInt$taxonomy.name.to, sep="-"))
paste(mgnInt$taxonomy.id.from, mgnInt$taxonomy.name.to, sep="-")
mgnInt$InterID <- as.numeric(paste(mgnInt$taxonomy.id.from, mgnInt$taxonomy.id.to, sep="-"))
paste(mgnInt$taxonomy.id.from, mgnInt$taxonomy.id.to, sep="-")
mgnInt$InterID <- paste(mgnInt$taxonomy.id.from, mgnInt$taxonomy.id.to, sep="-")
mgnInt %>% dplyr::filter(., grepl("NA", InterID)==FALSE)
x <- mgnInt %>% dplyr::filter(., grepl("NA", InterID)==FALSE)
mgIntTaxaFil <- mgnInt %>% dplyr::filter(., grepl("NA", InterID)==FALSE)
table(mgIntTaxaFil$InterID)
table(table(mgIntTaxaFil$InterID))
InterMangelCounts <- mgIntTaxaFil %>% dplyr::group_by(., InterID) %>% dplyr::summarise(., networks=length(unique(network_id)))
View(InterMangelCounts)
mgIntTaxaFil[mgIntTaxaFil$taxonomy.id.to==5038]
mgIntTaxaFil$network_id[mgIntTaxaFil$taxonomy.id.to==5038]
mgIntTaxaFil$network_id[mgIntTaxaFil$taxonomy.id.to==5038 & mgIntTaxaFil$taxonomy.id.from!=5031]
length(unique(mgIntTaxaFil$network_id[mgIntTaxaFil$taxonomy.id.to==5038 & mgIntTaxaFil$taxonomy.id.from!=5031]))
length(unique(mgIntTaxaFil$network_id[mgIntTaxaFil$taxonomy.id.to==5038 | mgIntTaxaFil$taxonomy.id.from!=5031]))
length(unique(mgIntTaxaFil$network_id[mgIntTaxaFil$taxonomy.id.from==5031 & mgIntTaxaFil$taxonomy.id.to!=5038])) #Number of networks including the bee but don't include the morning glory
length(unique(mgIntTaxaFil$network_id[mgIntTaxaFil$taxonomy.id.from==5031)) #Number of networks including the morning glory but not the bee
length(unique(mgIntTaxaFil$network_id[mgIntTaxaFil$taxonomy.id.from==5031) #Number of networks including the morning glory but not the bee
length(unique(mgIntTaxaFil$network_id[mgIntTaxaFil$taxonomy.id.from==5031])) #Number of networks including the morning glory but not the bee
& mgIntTaxaFil$taxonomy.id.to!=5038
length(unique(mgIntTaxaFil$network_id[mgIntTaxaFil$taxonomy.id.from==5031 & mgIntTaxaFil$taxonomy.id.to!=5038])) #Number of networks including the morning glory but not the bee
length(unique(mgIntTaxaFil$network_id[mgIntTaxaFil$taxonomy.id.to==5038 & mgIntTaxaFil$taxonomy.id.from!=5031])) #Number of networks including the bee but don't include the morning glory
